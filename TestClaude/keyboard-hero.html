<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyboard Hero</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Poppins:wght@300;400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: #0a0a0f;
            background-image:
                radial-gradient(at 20% 30%, rgba(120, 119, 198, 0.3) 0, transparent 50%),
                radial-gradient(at 80% 70%, rgba(255, 0, 128, 0.3) 0, transparent 50%),
                radial-gradient(at 40% 90%, rgba(0, 255, 255, 0.2) 0, transparent 50%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            background: rgba(10, 10, 20, 0.85);
            backdrop-filter: blur(20px);
            border-radius: 30px;
            position: relative;
            overflow: hidden;
            box-shadow:
                0 0 80px rgba(120, 119, 198, 0.4),
                0 20px 60px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #game-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 25px 30px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.6), transparent);
            backdrop-filter: blur(10px);
            display: grid;
            grid-template-columns: auto 1fr auto auto auto auto;
            gap: 15px;
            align-items: center;
            z-index: 100;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .hub-btn {
            padding: 8px 20px;
            font-size: 14px;
            font-weight: 600;
            background: rgba(0, 245, 255, 0.1);
            border: 2px solid rgba(0, 245, 255, 0.3);
            color: #00f5ff;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Poppins', sans-serif;
        }

        .hub-btn:hover {
            background: rgba(0, 245, 255, 0.2);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.4);
            transform: scale(1.05);
        }

        #score, #combo, #level, #lives {
            color: white;
            font-size: 20px;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
        }

        #lives {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.1);
            border-color: rgba(255, 68, 68, 0.3);
        }

        #combo {
            color: #ffd700;
            font-size: 24px;
            background: rgba(255, 215, 0, 0.1);
            border-color: rgba(255, 215, 0, 0.3);
            font-family: 'Orbitron', monospace;
        }

        #score {
            background: rgba(120, 119, 198, 0.2);
            border-color: rgba(120, 119, 198, 0.4);
        }

        #level {
            background: rgba(0, 255, 255, 0.1);
            border-color: rgba(0, 255, 255, 0.3);
            color: #00ffff;
        }

        #game-area {
            position: absolute;
            top: 80px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }

        .note {
            position: absolute;
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #ff006e 0%, #8338ec 100%);
            border-radius: 16px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            font-weight: 900;
            font-family: 'Orbitron', monospace;
            color: white;
            text-shadow:
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 0, 110, 0.6);
            box-shadow:
                0 0 30px rgba(255, 0, 110, 0.6),
                0 8px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: transform 0.1s;
            animation: notePulse 0.8s infinite alternate;
            z-index: 50;
        }

        .note.double {
            width: 150px;
            background: linear-gradient(135deg, #00f5ff 0%, #0066ff 100%);
            font-size: 26px;
            letter-spacing: 10px;
            box-shadow:
                0 0 30px rgba(0, 245, 255, 0.8),
                0 8px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-shadow:
                0 0 10px rgba(255, 255, 255, 1),
                0 0 20px rgba(0, 245, 255, 0.8);
        }

        .note.triple {
            width: 220px;
            background: linear-gradient(135deg, #ff00ff 0%, #ff6600 50%, #ffcc00 100%);
            font-size: 22px;
            letter-spacing: 8px;
            box-shadow:
                0 0 40px rgba(255, 0, 255, 0.9),
                0 8px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-shadow:
                0 0 15px rgba(255, 255, 255, 1),
                0 0 25px rgba(255, 0, 255, 0.9);
            animation: tripleNotePulse 0.6s infinite alternate;
        }

        .note.long {
            height: 180px;
            background: linear-gradient(180deg,
                #00ff88 0%,
                #00ff88 30%,
                rgba(0, 255, 136, 0.8) 70%,
                rgba(0, 255, 136, 0.4) 100%);
            border-radius: 16px 16px 8px 8px;
            box-shadow:
                0 0 35px rgba(0, 255, 136, 0.8),
                0 8px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-shadow:
                0 0 10px rgba(255, 255, 255, 1),
                0 0 20px rgba(0, 255, 136, 0.9);
            position: relative;
        }

        .note.long::after {
            content: '‚ñº HOLD ‚ñº';
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: 700;
            letter-spacing: 2px;
        }

        .note.long.holding {
            background: linear-gradient(180deg,
                #00ffff 0%,
                #00ffff 30%,
                rgba(0, 255, 255, 0.8) 70%,
                rgba(0, 255, 255, 0.4) 100%);
            box-shadow:
                0 0 50px rgba(0, 255, 255, 1),
                0 8px 16px rgba(0, 0, 0, 0.4);
            animation: holdingPulse 0.3s infinite alternate;
        }

        @keyframes holdingPulse {
            from {
                filter: brightness(1);
            }
            to {
                filter: brightness(1.4);
            }
        }

        @keyframes tripleNotePulse {
            from {
                transform: scale(1) rotate(-2deg);
                filter: brightness(1) hue-rotate(0deg);
            }
            to {
                transform: scale(1.1) rotate(2deg);
                filter: brightness(1.3) hue-rotate(10deg);
            }
        }

        @keyframes notePulse {
            from {
                transform: scale(1) rotate(0deg);
                filter: brightness(1);
            }
            to {
                transform: scale(1.08) rotate(2deg);
                filter: brightness(1.2);
            }
        }

        #hit-zone {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 120px;
            background: linear-gradient(to top,
                rgba(255, 215, 0, 0.15) 0%,
                rgba(255, 215, 0, 0.08) 50%,
                transparent 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: 1;
        }

        #perfect-zone {
            position: absolute;
            bottom: 40px;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(to bottom,
                rgba(0, 255, 200, 0.25),
                rgba(0, 255, 150, 0.3),
                rgba(0, 255, 200, 0.25));
            pointer-events: none;
            animation: perfectZonePulse 1.5s infinite alternate;
            z-index: 2;
            box-shadow: 0 0 40px rgba(0, 255, 200, 0.4);
        }

        @keyframes perfectZonePulse {
            from {
                opacity: 0.7;
                box-shadow: 0 0 30px rgba(0, 255, 200, 0.3);
            }
            to {
                opacity: 1;
                box-shadow: 0 0 50px rgba(0, 255, 200, 0.6);
            }
        }

        .zone-line {
            position: absolute;
            left: 0;
            right: 0;
            height: 3px;
            pointer-events: none;
            z-index: 100;
        }

        .zone-line.perfect-top {
            bottom: -40px;
            background: linear-gradient(to right,
                transparent,
                #00ffcc 20%,
                #00ff88 50%,
                #00ffcc 80%,
                transparent);
            box-shadow:
                0 0 20px rgba(0, 255, 200, 1),
                0 0 40px rgba(0, 255, 200, 0.5);
            animation: perfectLinePulse 1.5s infinite alternate;
        }

        .zone-line.perfect-bottom {
            bottom: -80px;
            background: linear-gradient(to right,
                transparent,
                #00ffcc 20%,
                #00ff88 50%,
                #00ffcc 80%,
                transparent);
            box-shadow:
                0 0 20px rgba(0, 255, 200, 1),
                0 0 40px rgba(0, 255, 200, 0.5);
            animation: perfectLinePulse 1.5s infinite alternate;
        }

        .zone-line.hit-top {
            bottom: 0px;
            background: linear-gradient(to right,
                transparent,
                #ffd700 20%,
                #ffed4e 50%,
                #ffd700 80%,
                transparent);
            box-shadow:
                0 0 15px rgba(255, 215, 0, 0.8),
                0 0 30px rgba(255, 215, 0, 0.4);
        }

        @keyframes perfectLinePulse {
            from {
                box-shadow:
                    0 0 15px rgba(0, 255, 200, 0.8),
                    0 0 30px rgba(0, 255, 200, 0.4);
                opacity: 0.9;
            }
            to {
                box-shadow:
                    0 0 25px rgba(0, 255, 200, 1),
                    0 0 50px rgba(0, 255, 200, 0.6);
                opacity: 1;
            }
        }

        #hit-indicator {
            color: white;
            font-size: 56px;
            font-weight: 900;
            font-family: 'Orbitron', monospace;
            text-shadow:
                0 0 30px rgba(255, 215, 0, 1),
                0 0 60px rgba(255, 215, 0, 0.6);
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
            z-index: 150;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            color: white;
        }

        #game-over-screen {
            display: none;
        }

        h1 {
            font-size: 72px;
            margin-bottom: 30px;
            font-family: 'Orbitron', monospace;
            font-weight: 900;
            background: linear-gradient(135deg, #ff006e 0%, #00f5ff 50%, #8338ec 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 30px rgba(255, 0, 110, 0.5));
            animation: titleGlow 3s infinite alternate;
        }

        @keyframes titleGlow {
            from {
                filter: drop-shadow(0 0 20px rgba(255, 0, 110, 0.4));
            }
            to {
                filter: drop-shadow(0 0 40px rgba(0, 245, 255, 0.6));
            }
        }

        .btn {
            padding: 18px 45px;
            font-size: 22px;
            font-weight: 700;
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #ff006e 0%, #8338ec 100%);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            box-shadow:
                0 0 30px rgba(255, 0, 110, 0.4),
                0 8px 20px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow:
                0 0 40px rgba(255, 0, 110, 0.6),
                0 12px 30px rgba(0, 0, 0, 0.5);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: scale(0.98);
        }

        #instructions {
            margin: 20px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
            font-size: 18px;
        }

        #final-score {
            font-size: 48px;
            color: #ffd700;
            margin: 20px 0;
        }

        .hit-effect {
            position: absolute;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: radial-gradient(circle,
                rgba(0, 255, 200, 0.8) 0%,
                rgba(255, 215, 0, 0.6) 40%,
                transparent 70%);
            pointer-events: none;
            animation: expand 0.6s ease-out forwards;
            box-shadow: 0 0 50px rgba(0, 255, 200, 0.8);
        }

        @keyframes expand {
            from {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }
            to {
                transform: scale(2.5) rotate(180deg);
                opacity: 0;
            }
        }

        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #00ffcc;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 10px #00ffcc;
            animation: particle-fly 0.8s ease-out forwards;
        }

        @keyframes particle-fly {
            from {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            to {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        #difficulty-selector {
            margin: 20px 0;
        }

        .difficulty-btn {
            padding: 12px 30px;
            font-size: 18px;
            font-weight: 600;
            margin: 0 10px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Poppins', sans-serif;
        }

        .difficulty-btn.selected {
            background: linear-gradient(135deg, #00f5ff 0%, #0066ff 100%);
            color: white;
            border-color: #00f5ff;
            box-shadow: 0 0 30px rgba(0, 245, 255, 0.6);
        }

        .difficulty-btn:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .difficulty-btn.selected:hover {
            background: linear-gradient(135deg, #00f5ff 0%, #0066ff 100%);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen">
            <h1>üéÆ Keyboard Hero üéÆ</h1>
            <div id="instructions">
                <p>Premi le lettere che cadono quando raggiungono la zona dorata!</p>
                <p>Pi√π sei preciso, pi√π punti ottieni!</p>
                <p><strong>Perfect:</strong> 100 punti (zona verde) | <strong>Good:</strong> 50 punti</p>
                <p><strong>Hai 5 vite!</strong> Ogni lettera persa ti fa perdere una vita!</p>
                <p style="margin-top: 15px; color: #00ffcc;">üíé <strong>Note speciali:</strong> Doppie, Triple e Lunghe (HOLD) appaiono progressivamente!</p>
                <p style="margin-top: 10px; color: #ff8888; font-size: 14px;">‚ö†Ô∏è Click anticipati = penalit√† punti!</p>
            </div>
            <div id="difficulty-selector">
                <button class="difficulty-btn selected" data-difficulty="medium">Medio</button>
                <button class="difficulty-btn" data-difficulty="hard">Difficile</button>
            </div>
            <div id="records-display" style="margin: 20px 0; font-size: 20px; color: #ffd700;">
                <strong>Record:</strong> <span id="high-score-display">0</span>
            </div>
            <button class="btn" onclick="startGame()">Inizia a Giocare!</button>
        </div>

        <div id="game-over-screen">
            <h1>Game Over!</h1>
            <div id="final-score"></div>
            <button class="btn" onclick="restartGame()">Gioca Ancora</button>
            <button class="btn" onclick="backToMenu()">Menu Principale</button>
            <button class="btn" onclick="backToHub()" style="background: linear-gradient(135deg, #00f5ff 0%, #0066ff 100%);">Torna all'Hub</button>
        </div>

        <div id="game-header">
            <button class="hub-btn" onclick="backToHub()">‚Üê Hub</button>
            <div></div>
            <div id="score">Punteggio: 0</div>
            <div id="combo">Combo: 0x</div>
            <div id="level">Livello: 1</div>
            <div id="lives">‚ù§Ô∏è Vite: 5</div>
        </div>

        <div id="game-area">
            <!-- Zone lines sempre visibili -->
            <div class="zone-line hit-top"></div>
            <div class="zone-line perfect-top"></div>
            <div class="zone-line perfect-bottom"></div>
        </div>

        <div id="hit-zone">
            <div id="perfect-zone"></div>
            <div id="hit-indicator"></div>
        </div>
    </div>

    <script>
        const gameArea = document.getElementById('game-area');
        const hitZone = document.getElementById('hit-zone');
        const scoreDisplay = document.getElementById('score');
        const comboDisplay = document.getElementById('combo');
        const levelDisplay = document.getElementById('level');
        const livesDisplay = document.getElementById('lives');
        const hitIndicator = document.getElementById('hit-indicator');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');

        let score = 0;
        let combo = 0;
        let level = 1;
        let lives = 5;
        let gameRunning = false;
        let notes = [];
        let activeKeys = new Set();
        let heldKeys = new Set();
        let activeHoldNotes = new Map(); // Track which keys are holding which notes
        let spawnInterval;
        let difficulty = 'medium';
        let currentSpeed = 3;
        let currentSpawnRate = 1500;
        let lastKeyPressTime = new Map(); // Track last press time for each key

        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

        const difficultySettings = {
            medium: { baseSpeed: 3, baseSpawnRate: 1500, hitZoneSize: 100 },
            hard: { baseSpeed: 4, baseSpawnRate: 1000, hitZoneSize: 80 }
        };

        // Funzione per calcolare la probabilit√† di note multiple in base al punteggio
        function getMultiKeyChances() {
            let doubleChance = 0;
            let tripleChance = 0;
            let longChance = 0;

            // Note doppie: partono da 0%, raggiungono il 30% a 5000 punti
            if (score > 0) {
                doubleChance = Math.min(0.30, (score / 5000) * 0.30);
            }

            // Note lunghe: partono da 0% a 2500 punti, raggiungono il 25% a 7500 punti
            if (score >= 2500) {
                longChance = Math.min(0.25, ((score - 2500) / 5000) * 0.25);
            }

            // Note triple: partono da 0% a 5000 punti, raggiungono il 20% a 10000 punti
            if (score >= 5000) {
                tripleChance = Math.min(0.20, ((score - 5000) / 5000) * 0.20);
            }

            return { doubleChance, tripleChance, longChance };
        }

        // Initialize Supabase
        const SUPABASE_URL = 'https://yisvilyrnvzmodlydwvi.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inlpc3ZpbHlybnZ6bW9kbHlkd3ZpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA1NTU1NjEsImV4cCI6MjA3NjEzMTU2MX0.K1s6NwPbHkH_Rz_Fv1qAO1Znde7oNLd4BE-g7BEfUco';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Get nickname from URL
        const urlParams = new URLSearchParams(window.location.search);
        const currentNickname = urlParams.get('nickname') || 'Guest';

        let highScores = { medium: 0, hard: 0 };

        // Load high scores from Supabase
        async function loadHighScores() {
            try {
                const { data, error } = await supabase
                    .from('scores')
                    .select('difficulty, score')
                    .eq('nickname', currentNickname)
                    .eq('game', 'keyboard-hero')
                    .order('score', { ascending: false });

                if (error) {
                    console.error('Error loading scores:', error);
                    return;
                }

                // Get best score per difficulty
                data.forEach(item => {
                    if (!highScores[item.difficulty] || item.score > highScores[item.difficulty]) {
                        highScores[item.difficulty] = item.score;
                    }
                });

                updateHighScoreDisplay();
            } catch (err) {
                console.error('Error:', err);
            }
        }

        function updateHighScoreDisplay() {
            const display = document.getElementById('high-score-display');
            if (display) {
                display.textContent = highScores[difficulty] || 0;
            }
        }

        async function saveHighScore() {
            const finalScore = Math.floor(score);

            if (finalScore > (highScores[difficulty] || 0)) {
                highScores[difficulty] = finalScore;

                try {
                    // Save to Supabase
                    const { error } = await supabase
                        .from('scores')
                        .insert({
                            nickname: currentNickname,
                            game: 'keyboard-hero',
                            difficulty: difficulty,
                            score: finalScore
                        });

                    if (error) {
                        console.error('Error saving score:', error);
                        return false;
                    }

                    return true;
                } catch (err) {
                    console.error('Error:', err);
                    return false;
                }
            }
            return false;
        }

        // Load scores on page load
        loadHighScores();

        // Difficulty selection
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
                this.classList.add('selected');
                difficulty = this.dataset.difficulty;
                updateHighScoreDisplay();
            });
        });

        // Initialize high score display
        updateHighScoreDisplay();

        function startGame() {
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            score = 0;
            combo = 0;
            level = 1;
            lives = 5;
            notes = [];
            gameRunning = true;

            // Reset speed to base difficulty settings
            const settings = difficultySettings[difficulty];
            currentSpeed = settings.baseSpeed;
            currentSpawnRate = settings.baseSpawnRate;

            updateScore();
            updateCombo();
            updateLevel();
            updateLives();
            spawnNotes();
            gameLoop();
        }

        function restartGame() {
            startGame();
        }

        function backToMenu() {
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'flex';
        }

        function backToHub() {
            window.location.href = 'index.html';
        }

        async function endGame() {
            gameRunning = false;
            clearInterval(spawnInterval);

            const finalScore = Math.floor(score);
            const isNewRecord = await saveHighScore();
            const finalScoreText = `Punteggio Finale: ${finalScore}`;
            const recordText = isNewRecord ? '<br><span style="color: #00ff00;">üéâ NUOVO RECORD! üéâ</span>' : '';

            document.getElementById('final-score').innerHTML = finalScoreText + recordText;
            gameOverScreen.style.display = 'flex';

            // Update high score display
            updateHighScoreDisplay();

            // Clear all notes
            notes.forEach(note => {
                if (note.element && note.element.parentNode) {
                    note.element.remove();
                }
            });
            notes = [];
        }

        function spawnNotes() {
            const settings = difficultySettings[difficulty];

            function spawn() {
                if (!gameRunning) return;

                // Get dynamic chances based on score
                const { doubleChance, tripleChance, longChance } = getMultiKeyChances();
                const rand = Math.random();

                let letter;
                let noteType = 'single';
                let noteWidth = 70;
                let noteHeight = 70;


                // Determine note type (order matters for probabilities)
                if (longChance > 0 && rand < longChance) {
                    // Long note (hold)
                    noteType = 'long';
                    noteHeight = 180;
                    letter = letters[Math.floor(Math.random() * letters.length)];
                } else if (tripleChance > 0 && rand < longChance + tripleChance) {
                    // Triple note
                    noteType = 'triple';
                    noteWidth = 220;
                    const usedLetters = new Set();
                    letter = '';
                    for (let i = 0; i < 3; i++) {
                        let newLetter;
                        do {
                            newLetter = letters[Math.floor(Math.random() * letters.length)];
                        } while (usedLetters.has(newLetter));
                        usedLetters.add(newLetter);
                        letter += newLetter;
                    }
                } else if (rand < longChance + tripleChance + doubleChance) {
                    // Double note
                    noteType = 'double';
                    noteWidth = 150;
                    const letter1 = letters[Math.floor(Math.random() * letters.length)];
                    let letter2;
                    do {
                        letter2 = letters[Math.floor(Math.random() * letters.length)];
                    } while (letter2 === letter1);
                    letter = letter1 + letter2;
                } else {
                    // Single note
                    letter = letters[Math.floor(Math.random() * letters.length)];
                }

                const note = {
                    letter: letter,
                    x: Math.random() * (gameArea.offsetWidth - noteWidth),
                    y: noteType === 'long' ? -200 : -80,
                    element: null,
                    isDouble: noteType === 'double',
                    isTriple: noteType === 'triple',
                    isLong: noteType === 'long',
                    isHolding: false,
                    holdStartTime: null,
                    holdDuration: 0
                };

                const noteElement = document.createElement('div');
                noteElement.className = 'note';
                if (noteType === 'double') noteElement.classList.add('double');
                if (noteType === 'triple') noteElement.classList.add('triple');
                if (noteType === 'long') noteElement.classList.add('long');
                noteElement.textContent = letter;
                noteElement.style.left = note.x + 'px';
                noteElement.style.top = note.y + 'px';

                gameArea.appendChild(noteElement);
                note.element = noteElement;
                notes.push(note);

                // Schedule next spawn with dynamic spawn rate
                setTimeout(spawn, currentSpawnRate);
            }

            spawn(); // Start spawning
        }

        function gameLoop() {
            if (!gameRunning) return;

            const settings = difficultySettings[difficulty];
            const hitZoneTop = gameArea.offsetHeight - settings.hitZoneSize;
            const hitZoneBottom = gameArea.offsetHeight;
            const currentTime = Date.now();

            notes.forEach((note, index) => {
                // Update hold duration if holding
                if (note.isLong && note.isHolding && note.holdStartTime) {
                    note.holdDuration = currentTime - note.holdStartTime;
                }

                note.y += currentSpeed;
                note.element.style.top = note.y + 'px';

                // Check if long note finished holding successfully
                if (note.isLong && note.isHolding) {
                    const noteTop = note.y;
                    const noteBottom = note.y + 180;

                    // If note has passed the hit zone, award points based on hold duration
                    if (noteTop > hitZoneBottom) {
                        const holdSeconds = note.holdDuration / 1000;
                        const pointsEarned = Math.floor(200 * Math.min(holdSeconds / 1.5, 1) * (1 + combo * 0.1));
                        score += pointsEarned;
                        combo++;

                        showHitIndicator(`+${pointsEarned}`);
                        createHitEffect(note.x + 35, hitZoneBottom - 50);

                        note.element.remove();
                        notes.splice(index, 1);
                        updateScore();
                        updateCombo();

                        // Remove from active hold notes
                        activeHoldNotes.delete(note.letter.toUpperCase());
                        return;
                    }
                }

                // Check if note is past the screen
                const noteHeight = note.isLong ? 180 : 70;
                if (note.y > gameArea.offsetHeight + noteHeight) {
                    note.element.remove();
                    notes.splice(index, 1);

                    // Only penalize if it wasn't being held
                    if (!note.isLong || !note.isHolding) {
                        missNote();
                    }

                    // Remove from active hold notes if it was there
                    if (note.isLong) {
                        activeHoldNotes.delete(note.letter.toUpperCase());
                    }
                }
            });

            // Update level and speed based on score
            const newLevel = Math.floor(score / 1000) + 1;
            if (newLevel > level) {
                level = newLevel;
                updateLevel();

                // Increase speed gradually (max 2x base speed)
                const speedMultiplier = 1 + (level - 1) * 0.1;
                currentSpeed = Math.min(settings.baseSpeed * speedMultiplier, settings.baseSpeed * 2);

                // Decrease spawn rate (faster spawning, min 0.5x base rate)
                const spawnMultiplier = 1 - (level - 1) * 0.05;
                currentSpawnRate = Math.max(settings.baseSpawnRate * spawnMultiplier, settings.baseSpawnRate * 0.5);
            }

            requestAnimationFrame(gameLoop);
        }

        function checkHit(key, isKeyDown = true) {
            const settings = difficultySettings[difficulty];
            const hitZoneTop = gameArea.offsetHeight - settings.hitZoneSize;
            const hitZoneBottom = gameArea.offsetHeight;
            const perfectZoneTop = gameArea.offsetHeight - 65;
            const perfectZoneBottom = gameArea.offsetHeight - 35;

            let hit = false;
            let hitQuality = null;

            for (let index = notes.length - 1; index >= 0; index--) {
                const note = notes[index];

                if (note.letter === key.toUpperCase()) {
                    const noteHeight = note.isLong ? 180 : 70;
                    const noteBottom = note.y + noteHeight;
                    const noteCenter = note.y + (noteHeight / 2);
                    const noteTop = note.y;

                    // Handle long notes (hold)
                    if (note.isLong && isKeyDown) {
                        // Check if note head is in hit zone
                        if (noteTop >= hitZoneTop && noteTop <= hitZoneBottom) {
                            note.isHolding = true;
                            note.holdStartTime = Date.now();
                            note.element.classList.add('holding');
                            activeHoldNotes.set(key.toUpperCase(), note);
                            hit = true;
                            showHitIndicator('HOLD!');
                            break;
                        } else if (noteTop < hitZoneTop) {
                            // Clicked too early - penalize
                            score = Math.max(0, score - 30);
                            combo = 0;
                            showHitIndicator('-30');
                            updateScore();
                            updateCombo();
                            hit = true;
                            break;
                        }
                    }
                    // Handle normal notes
                    else if (!note.isLong) {
                        // Check if note is in hit zone
                        if (noteCenter >= hitZoneTop && noteCenter <= hitZoneBottom) {
                            // Check if in perfect zone (green zone)
                            if (noteCenter >= perfectZoneTop && noteCenter <= perfectZoneBottom) {
                                hitQuality = 'PERFECT';
                                score += 100 * (1 + combo * 0.1);
                            } else {
                                hitQuality = 'GOOD';
                                score += 50 * (1 + combo * 0.1);
                            }

                            combo++;
                            hit = true;

                            // Visual feedback
                            showHitIndicator(hitQuality);
                            createHitEffect(note.x + 35, noteCenter);
                            note.element.style.animation = 'none';
                            note.element.style.transform = 'scale(1.5)';
                            note.element.style.opacity = '0';

                            setTimeout(() => {
                                if (note.element && note.element.parentNode) {
                                    note.element.remove();
                                }
                            }, 200);

                            notes.splice(index, 1);
                            updateScore();
                            updateCombo();
                            break;
                        } else if (noteCenter < hitZoneTop) {
                            // Clicked too early - penalize
                            score = Math.max(0, score - 30);
                            combo = 0;
                            showHitIndicator('-30');
                            updateScore();
                            updateCombo();
                            hit = true;
                            break;
                        }
                    }
                }
            }

            return hit;
        }

        function missNote() {
            combo = 0;
            lives--;
            updateLives();
            showHitIndicator('MISS');

            // Check if game over
            if (lives <= 0) {
                endGame();
            }
        }

        function showHitIndicator(text) {
            hitIndicator.textContent = text;
            hitIndicator.style.opacity = '1';
            hitIndicator.style.transform = 'scale(1.2)';

            if (text === 'PERFECT') {
                hitIndicator.style.color = '#00ffcc';
                hitIndicator.style.textShadow = '0 0 30px #00ffcc, 0 0 60px #00ffcc';
            } else if (text === 'GOOD') {
                hitIndicator.style.color = '#ffd700';
                hitIndicator.style.textShadow = '0 0 30px #ffd700, 0 0 60px #ffd700';
            } else {
                hitIndicator.style.color = '#ff0044';
                hitIndicator.style.textShadow = '0 0 30px #ff0044, 0 0 60px #ff0044';
            }

            setTimeout(() => {
                hitIndicator.style.opacity = '0';
                hitIndicator.style.transform = 'scale(1)';
            }, 300);
        }

        function createHitEffect(x, y) {
            const effect = document.createElement('div');
            effect.className = 'hit-effect';
            effect.style.left = (x - 75) + 'px';
            effect.style.top = (y - 75) + 'px';
            gameArea.appendChild(effect);

            // Create particles
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                const angle = (Math.PI * 2 * i) / 12;
                const distance = 60 + Math.random() * 40;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.setProperty('--tx', tx + 'px');
                particle.style.setProperty('--ty', ty + 'px');
                gameArea.appendChild(particle);

                setTimeout(() => particle.remove(), 800);
            }

            setTimeout(() => {
                effect.remove();
            }, 600);
        }

        function updateScore() {
            scoreDisplay.textContent = `Punteggio: ${Math.floor(score)}`;
        }

        function updateCombo() {
            comboDisplay.textContent = `Combo: ${combo}x`;
            if (combo > 0) {
                comboDisplay.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    comboDisplay.style.transform = 'scale(1)';
                }, 100);
            }
        }

        function updateLevel() {
            levelDisplay.textContent = `Livello: ${level}`;
        }

        function updateLives() {
            livesDisplay.textContent = `‚ù§Ô∏è Vite: ${lives}`;
            if (lives <= 2) {
                livesDisplay.style.color = '#ff0000';
                livesDisplay.style.animation = 'pulse 0.5s infinite';
            } else {
                livesDisplay.style.color = '#ff4444';
                livesDisplay.style.animation = 'none';
            }
        }

        // Keyboard event listeners
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;

            const key = e.key.toLowerCase();

            // Prevent repeated keydown events
            if (activeKeys.has(key)) return;
            activeKeys.add(key);

            // Check if it's a letter
            if (/^[a-z]$/.test(key)) {
                let hit = false;

                // Check for triple key notes first (if 3 keys are pressed)
                if (activeKeys.size >= 3) {
                    const sortedKeys = Array.from(activeKeys).sort().join('').toUpperCase();

                    for (let i = notes.length - 1; i >= 0; i--) {
                        const note = notes[i];
                        if (note.isTriple) {
                            const noteSorted = note.letter.split('').sort().join('');
                            if (noteSorted === sortedKeys) {
                                hit = checkHit(note.letter);
                                if (hit) break;
                            }
                        }
                    }
                }

                // Check for double key notes if no triple hit
                if (!hit && activeKeys.size >= 2) {
                    const sortedKeys = Array.from(activeKeys).sort().join('').toUpperCase();

                    for (let i = notes.length - 1; i >= 0; i--) {
                        const note = notes[i];
                        if (note.isDouble) {
                            const noteSorted = note.letter.split('').sort().join('');
                            if (noteSorted === sortedKeys) {
                                hit = checkHit(note.letter);
                                if (hit) break;
                            }
                        }
                    }
                }

                // If no multi-key hit, try single key
                if (!hit) {
                    hit = checkHit(key);
                }

                if (!hit && combo > 0) {
                    // Wrong key pressed
                    combo = Math.max(0, combo - 1);
                    updateCombo();
                }
            }

            // ESC to pause/end game
            if (e.key === 'Escape') {
                endGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            activeKeys.delete(key);

            // Handle long note release
            if (/^[a-z]$/.test(key)) {
                const upperKey = key.toUpperCase();
                const holdNote = activeHoldNotes.get(upperKey);

                if (holdNote && holdNote.isHolding) {
                    // Released too early - penalize
                    const holdDuration = (Date.now() - holdNote.holdStartTime) / 1000;
                    if (holdDuration < 1.0) {
                        score = Math.max(0, score - 50);
                        combo = 0;
                        showHitIndicator('-50 EARLY!');
                        updateScore();
                        updateCombo();

                        // Remove the note
                        holdNote.element.remove();
                        const noteIndex = notes.indexOf(holdNote);
                        if (noteIndex > -1) {
                            notes.splice(noteIndex, 1);
                        }
                    }

                    activeHoldNotes.delete(upperKey);
                }
            }
        });

        // Prevent default behavior for letter keys to avoid page scrolling
        window.addEventListener('keydown', (e) => {
            if (/^[a-z]$/.test(e.key.toLowerCase()) && gameRunning) {
                e.preventDefault();
            }
        });
    </script>
</body>
</html>